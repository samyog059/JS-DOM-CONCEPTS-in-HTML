<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pathfinding Robot â€” A*</title>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: radial-gradient(circle at 20% 20%, #1d2b3a, #0f1724 55%);
      --card: #111927;
      --grid-line: rgba(255, 255, 255, 0.05);
      --accent: #00ffcc;
      --accent-strong: #17b392;
      --text: #e7edf4;
      --muted: #a5b0c0;
      --warn: #f10000;
      --shadow: 0 14px 40px rgba(0, 0, 0, 0.35);
      --radius: 14px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Manrope', 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .app {
      width: min(1200px, 100%);
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 18px;
    }

    .panel {
      background: var(--card);
      border-radius: var(--radius);
      padding: 20px 18px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .panel h1 {
      margin: 0 0 6px 0;
      font-size: 24px;
      letter-spacing: -0.3px;
    }

    .panel p { margin: 0 0 14px 0; color: var(--muted); }

    .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 12px; }

    .controls button, .controls select {
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 10px 12px;
      min-width: 90px;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease, border 120ms ease;
      font-weight: 600;
    }

    .controls button:hover, .controls select:hover {
      transform: translateY(-1px);
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.12);
    }

    .controls button.primary { background: var(--accent); color: #0f1724; border-color: transparent; }
    .controls button.primary:hover { background: var(--accent-strong); }

    .legend { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px 12px; margin-top: 10px; font-size: 14px; color: var(--muted); }
    .legend span { display: inline-flex; align-items: center; gap: 8px; }
    .swatch { width: 16px; height: 16px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.2); }

    .grid-wrap {
      position: relative;
      aspect-ratio: 1 / 1;
      background: rgba(255, 255, 255, 0.02);
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.07);
    }

    .grid {
      display: grid;
      height: 100%;
      width: 100%;
      grid-template-columns: repeat(20, 1fr);
      grid-template-rows: repeat(20, 1fr);
    }

    .cell {
      border: 1px solid var(--grid-line);
      background: rgba(255, 255, 255, 0.01);
      transition: background 120ms ease, transform 120ms ease;
    }

    .cell:hover { background: rgba(255, 255, 255, 0.04); }
    .cell.start { background: linear-gradient(135deg, #1dd3b0, #15a882); }
    .cell.goal { background: linear-gradient(135deg, #5b8bf7, #486be6); }
    .cell.wall { background: #1e2a3c; border-color: rgba(0, 0, 0, 0.3); }
    .cell.path { background: rgba(29, 211, 176, 0.35); }
    .cell.visited { background: rgba(90, 126, 255, 0.18); }

    .robot {
      position: absolute;
      top: 0;
      left: 0;
      width: 0;
      height: 0;
      pointer-events: none;
      transform-origin: center;
      transition: transform 260ms ease;
      opacity: 0;
    }

    .robot .marker {
      position: absolute;
      inset: 18%;
      background: radial-gradient(circle at 30% 30%, #ffffff 28%, #1dd3b0 75%);
      border-radius: 50%;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    .robot .marker::after {
      content: '';
      position: absolute;
      top: -32%;
      left: 34%;
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 0 7px 14px 7px;
      border-color: transparent transparent #1dd3b0 transparent;
      filter: drop-shadow(0 6px 10px rgba(0, 0, 0, 0.4));
      transform: rotate(-6deg);
    }

    .status { margin-top: 14px; font-size: 14px; color: var(--muted); min-height: 20px; }
    .status strong { color: var(--accent); }

    @media (max-width: 960px) {
      .app { grid-template-columns: 1fr; }
      .grid-wrap { min-height: 60vh; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>Pathfinding Robot</h1>
      <p>Lay walls, set start and goal, then watch A* chart the shortest route.</p>
      <div class="controls">
        <select id="mode">
          <option value="wall">Draw Walls</option>
          <option value="start">Place Start</option>
          <option value="goal">Place Goal</option>
        </select>
        <button id="run" class="primary">Run A*</button>
        <button id="clear">Clear</button>
        <button id="reset">Reset</button>
      </div>
      <div class="legend">
        <span><span class="swatch" style="background:#1dd3b0"></span>Start</span>
        <span><span class="swatch" style="background:#5b8bf7"></span>Goal</span>
        <span><span class="swatch" style="background:#1e2a3c"></span>Wall</span>
        <span><span class="swatch" style="background:rgba(29,211,176,0.35)"></span>Path</span>
      </div>
      <div class="status" id="status">Click to place start and goal, then run.</div>
    </div>

    <div class="grid-wrap">
      <div class="grid" id="grid"></div>
      <div id="robot" class="robot"><div class="marker"></div></div>
    </div>
  </div>

  <script>
    const gridSize = 20;
    const gridEl = document.getElementById('grid');
    const statusEl = document.getElementById('status');
    const modeEl = document.getElementById('mode');
    const runBtn = document.getElementById('run');
    const clearBtn = document.getElementById('clear');
    const resetBtn = document.getElementById('reset');
    const robotEl = document.getElementById('robot');

    let start = null;
    let goal = null;
    const walls = new Set();
    let stopAnimation = false;

    function cellKey(r, c) { return `${r},${c}`; }

    function renderGrid() {
      gridEl.innerHTML = '';
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.r = r;
          cell.dataset.c = c;
          cell.addEventListener('mouseenter', handleDrawHover);
          cell.addEventListener('mousedown', handleCellAction);
          cell.addEventListener('click', handleCellAction);
          gridEl.appendChild(cell);
        }
      }
    }

    function handleDrawHover(e) {
      if (e.buttons !== 1 || modeEl.value !== 'wall') return;
      toggleWall(e.target);
    }

    function handleCellAction(e) {
      const target = e.target;
      const r = Number(target.dataset.r);
      const c = Number(target.dataset.c);
      const mode = modeEl.value;

      if (mode === 'wall') {
        toggleWall(target);
        return;
      }

      if (mode === 'start') {
        start = { r, c };
        placeRobotAtStart();
      } else if (mode === 'goal') {
        goal = { r, c };
      }
      repaint();
    }

    function toggleWall(target) {
      const key = cellKey(Number(target.dataset.r), Number(target.dataset.c));
      if (start && key === cellKey(start.r, start.c)) return;
      if (goal && key === cellKey(goal.r, goal.c)) return;
      if (walls.has(key)) walls.delete(key); else walls.add(key);
      repaint();
    }

    function repaint(path = [], visited = new Set()) {
      for (const cell of gridEl.children) {
        cell.classList.remove('wall', 'start', 'goal', 'path', 'visited');
        const key = cellKey(Number(cell.dataset.r), Number(cell.dataset.c));
        if (walls.has(key)) cell.classList.add('wall');
      }

      if (start) {
        const idx = start.r * gridSize + start.c;
        gridEl.children[idx].classList.add('start');
        placeRobotAtStart();
      }
      if (goal) {
        const idx = goal.r * gridSize + goal.c;
        gridEl.children[idx].classList.add('goal');
      }
      for (const key of visited) {
        const [r, c] = key.split(',').map(Number);
        const idx = r * gridSize + c;
        gridEl.children[idx]?.classList.add('visited');
      }
      for (const node of path) {
        const idx = node.r * gridSize + node.c;
        gridEl.children[idx]?.classList.add('path');
      }
    }

    function neighbors(r, c) {
      const deltas = [ [1,0], [-1,0], [0,1], [0,-1] ];
      const result = [];
      for (const [dr, dc] of deltas) {
        const nr = r + dr, nc = c + dc;
        if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize && !walls.has(cellKey(nr, nc))) {
          result.push({ r: nr, c: nc });
        }
      }
      return result;
    }

    function heuristic(a, b) {
      return Math.abs(a.r - b.r) + Math.abs(a.c - b.c); // Manhattan distance
    }

    function runAStar() {
      if (!start || !goal) {
        statusEl.innerHTML = 'Place both start and goal.';
        return;
      }

      cancelRobotAnimation();

      const open = new Map(); // key -> node with g, f, parent
      const openQueue = []; // array of keys to emulate priority queue
      const closed = new Set();
      const visited = new Set();

      const startKey = cellKey(start.r, start.c);
      open.set(startKey, { ...start, g: 0, f: heuristic(start, goal), parent: null });
      openQueue.push(startKey);

      const popBest = () => {
        let bestIdx = 0;
        for (let i = 1; i < openQueue.length; i++) {
          const k = openQueue[i];
          if (open.get(k).f < open.get(openQueue[bestIdx]).f) bestIdx = i;
        }
        const bestKey = openQueue.splice(bestIdx, 1)[0];
        const bestNode = open.get(bestKey);
        open.delete(bestKey);
        return bestNode;
      };

      while (openQueue.length) {
        const current = popBest();
        const currentKey = cellKey(current.r, current.c);
        visited.add(currentKey);
        repaint([], visited);

        if (current.r === goal.r && current.c === goal.c) {
          const path = reconstruct(current);
          repaint(path, visited);
          statusEl.innerHTML = `<strong>Success:</strong> Path length ${path.length}`;
          animateRobot(path);
          return;
        }

        closed.add(currentKey);
        for (const nb of neighbors(current.r, current.c)) {
          const nbKey = cellKey(nb.r, nb.c);
          if (closed.has(nbKey)) continue;
          const tentativeG = current.g + 1;

          if (!open.has(nbKey) || tentativeG < open.get(nbKey).g) {
            const nbNode = { ...nb, g: tentativeG, f: tentativeG + heuristic(nb, goal), parent: current };
            open.set(nbKey, nbNode);
            if (!openQueue.includes(nbKey)) openQueue.push(nbKey);
          }
        }
      }

      statusEl.innerHTML = `<span style="color: var(--warn);">No path found.</span>`;
      repaint([], visited);
    }

    function reconstruct(node) {
      const path = [];
      let cur = node;
      while (cur) {
        path.push({ r: cur.r, c: cur.c });
        cur = cur.parent;
      }
      return path.reverse();
    }

    function clearWalls() {
      walls.clear();
      repaint();
      statusEl.textContent = 'Walls cleared.';
    }

    function resetAll() {
      walls.clear();
      start = null;
      goal = null;
      repaint();
      statusEl.textContent = 'Reset done. Place start and goal.';
      cancelRobotAnimation();
      hideRobot();
    }

    function getGridGeometry() {
      const gridRect = gridEl.getBoundingClientRect();
      const wrapRect = gridEl.parentElement.getBoundingClientRect();
      const cell = gridRect.width / gridSize;
      return {
        cell,
        originX: gridRect.left - wrapRect.left,
        originY: gridRect.top - wrapRect.top
      };
    }

    function placeRobotAtStart() {
      if (!start) return;
      const geo = getGridGeometry();
      robotEl.style.width = `${geo.cell}px`;
      robotEl.style.height = `${geo.cell}px`;
      robotEl.style.transform = `translate(${geo.originX + start.c * geo.cell}px, ${geo.originY + start.r * geo.cell}px) rotate(0deg)`;
      robotEl.style.opacity = '1';
    }

    function hideRobot() {
      robotEl.style.opacity = '0';
    }

    function directionAngle(prev, next) {
      if (!prev || !next) return 0;
      if (next.r < prev.r) return -90;
      if (next.r > prev.r) return 90;
      if (next.c > prev.c) return 0;
      if (next.c < prev.c) return 180;
      return 0;
    }

    async function animateRobot(path) {
      if (!path.length) return;
      stopAnimation = false;
      const geo = getGridGeometry();
      robotEl.style.width = `${geo.cell}px`;
      robotEl.style.height = `${geo.cell}px`;
      let prev = path[0];
      robotEl.style.transform = `translate(${geo.originX + prev.c * geo.cell}px, ${geo.originY + prev.r * geo.cell}px) rotate(0deg)`;
      robotEl.style.opacity = '1';

      for (let i = 1; i < path.length; i++) {
        if (stopAnimation) return;
        const step = path[i];
        const angle = directionAngle(prev, step);
        await new Promise(resolve => setTimeout(resolve, 260));
        robotEl.style.transform = `translate(${geo.originX + step.c * geo.cell}px, ${geo.originY + step.r * geo.cell}px) rotate(${angle}deg)`;
        prev = step;
      }
    }

    function cancelRobotAnimation() {
      stopAnimation = true;
    }

    runBtn.addEventListener('click', runAStar);
    clearBtn.addEventListener('click', clearWalls);
    resetBtn.addEventListener('click', resetAll);

    renderGrid();
    repaint();
  </script>
</body>
</html>
